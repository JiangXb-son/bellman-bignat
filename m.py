# Iterative Python 3 program to find 
# modular inverse using extended 
# Euclid algorithm 

# Returns modulo inverse of a with 
# respect to m using extended Euclid 
# Algorithm Assumption: a and m are 
# coprimes, i.e., gcd(a, m) = 1 
def modInverse(a, m) : 
	m0 = m 
	y = 0
	x = 1

	if (m == 1) : 
		return 0

	while (a > 1) : 

		# q is quotient 
		q = a // m 

		t = m 

		# m is remainder now, process 
		# same as Euclid's algo 
		m = a % m 
		a = t 
		t = y 

		# Update x and y 
		y = x - q * y 
		x = t 


	# Make x positive 
	if (x < 0) : 
		x = x + m0 

	return x 


# Driver program to test above function 
a = 3
m = 11
print("Modular multiplicative inverse is", 
	modInverse(a, m)) 

# This code is contributed by Nikita tiwari. 
N = 25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357
Ni = 29764918309593228068870189303630968889260504446722763605835172551803888822762135137065447918141628978252513126879037033950720641666725521924954679493259314337769376294992942632242378483694689200812406344882641425826604104418811964985378391693745163730475638551114638681901231370542556342409870267721880014271427038535203189314102393366861197853634666398008864113695241860192363051042468142511413384384143953457963615806358709221102084665749431439938777450433031804848358674371230127592918085271629047829977337045027699194117348011685208392212538306763702058662720018535836689758115837546844794627960775021790830140909
R = 1 << 2048
